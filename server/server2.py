import asyncio
import json
import os
import ssl

import cv2
import numpy as np
from aiohttp import web
from av import VideoFrame

from aiortc import RTCPeerConnection, RTCSessionDescription, VideoStreamTrack
from aiortc.contrib.media import MediaBlackhole, MediaPlayer, MediaRecorder

import lanedetect

ROOT = os.path.dirname(__file__)
pcs = set()


class ImageProcess(VideoStreamTrack):
	def __init__(self, track):
		super().__init__()
		self.track = track

	async def recv(self):
		#await screen.orientation.lock("landscape");
		frame = await self.track.recv()
		img = frame.to_ndarray(format='bgr24')
		#function call
		#img = rotateImage(img, 270)
		img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE) #rotate image
		img = lanedetect.detect(img)
		cv2.imshow('frame',img)
		cv2.waitKey(2)

		new_frame = VideoFrame.from_ndarray(img, format='bgr24')
		new_frame.pts = frame.pts
		new_frame.time_base = frame.time_base
		return new_frame

def send_msg(channel, msg):
	channel.send(msg)

async def index(request):                                               #webserver things
	content = open(os.path.join(ROOT, 'index.html'), 'r').read()
	return web.Response(content_type='text/html', text=content)

async def javascript(request):                                               #webserver things
	content = open(os.path.join(ROOT, 'client.js'), 'r').read()
	return web.Response(content_type='application/javascript', text=content)


async def offer(request):                                               #receives post request from website and creates sdp offer
	params = await request.json()                                                   #offer starts connecton
	offer = RTCSessionDescription(
		sdp=params['sdp'],
		type=params['type'])

	# recorder = MediaRecorder(os.path.join(ROOT, 'video.mp4'))	
	recorder = MediaBlackhole()					#######
	pc = RTCPeerConnection()
	pcs.add(pc)

	@pc.on('datachannel')
	def on_datachannel(channel):
		@channel.on('message')
		def on_message(message):
			send_msg(channel,lanedetect.msg)#data transfer function
			print("msg sent", lanedetect.msg)

	@pc.on('track')
	def on_track(track):
		print('Track %s received' % track.kind)
		#video function call here
		video = ImageProcess(track)
		recorder.addTrack(video)



		@track.on('ended')
		async def on_ended():
			print('Track %s ended' % track.kind)
			cv2.destroyAllWindows()
			await recorder.stop()

	await pc.setRemoteDescription(offer) 
	await recorder.start()
	answer = await pc.createAnswer()  
	await pc.setLocalDescription(answer)                                    #RTCSessionDescription generated by createOffer() or createAnswer()

	return web.Response(                                                    #send answer to website this will start data transfer
		content_type='application/json',
		text=json.dumps({
			'sdp': pc.localDescription.sdp,
			'type': pc.localDescription.type
		}))

async def on_shutdown(app):
	# close peer connections
	coros = [pc.close() for pc in pcs]
	await asyncio.gather(*coros)
	pcs.clear()


if __name__ == '__main__':
	ssl_context = ssl.SSLContext()
	ssl_context.load_cert_chain(os.path.join(ROOT, 'cert.pem'))
	print("cert loaded")
	app = web.Application()
	print("server started")
	app.on_shutdown.append(on_shutdown)
	app.router.add_get('/', index)
	app.router.add_get('/client.js', javascript)
	app.router.add_post('/offer', offer)
	web.run_app(app, port=8080, ssl_context=ssl_context)


